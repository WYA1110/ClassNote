# JVM体系结构
### 一、内存管理的划分
1. jvm在内存管理上分为堆、栈两大块，这一部分又可以叫做  
   jre运行时环境,jre运行基于hotspot(native本地环境)，基于jre运行时环境运行的pack200(解压缩包)，native本地环境又包含只读数据段，native本地方法栈，和代码段、数据段。本地方法栈中的代码段和数据段在内存中占据同一段空间（系统分页）
   
   
2. 永久带与元数据区(metaspace)
   
   永久带是metaspace的前身，metaspace以堆分配内存的方式分配空间，共有四个区，静态区，方法区，计数器区和字符串常量池。

### 二、文件运行情况
1. 加载
   
   运行时，jar包先加载到pack200中解压，解压之后通过hotspot编译成class文件，将文件中的符号量放到字符串常量池，方法加载到方法区，加载完方法区之后就会立刻在数据段生成一个量表，前一半为方法签名，后一半指向方法区对应方法的首地址，解释量表加载到静态区（初始化方法调用量表）
2. 运行
   
   加载完程序之后，cpu会指向解释器（代码段），此时程序会进入一个死循环来获取程序中类的地址（main调度到解释器去数据段里找方法签名，再从方法签名找程序首地址），获得地址之后在本地方法栈生成一个临时栈空间，/*解释器将方法区的代码编译成机器码，将函数首地址存入临时栈，函数运行。运行结束后临时栈会销毁，在运行同时会将代码顺序按照时间记录在数据段，如果程序运行结束，跳出循环，没结束则在原临时栈基础上在构建一个临时站空间读取下一个函数。（临时站空间之内不存放数据，解释器会将数据按照其特性分配到栈空间或者堆空间内）*/

   class文件存放在metaspace里，直接内存
3. 永久栈空间使用
   
   当程序执行时间足够长，其静态量表和存放在方法区的代码会按照最优执行时间转存到永久栈之内,再次调用则会从永久栈之中直接调用
   服务，作业
4. jit编译概念
   
   即jvm即时性编译，编译即执行
### 三、类加载过程
1. 类的加载
   
   类首次使用需要将类加载到数据段方法签名量表中（去常量池中找到类的方法签名，将方法签名加载到数据段量表中），当首次使用成立的时候，java的 *反射* 功能会在堆区生成一个对应类的对象class（class实际上是一个hashmap，存放方法的名字和对应的首地址）
   String s =new string
   gc
   *new+对象就是在堆里创建空间*；
  *不是基本类型就要用new在堆里开辟空间*

  对象的名字代表对象信息的首地址存放在栈里，但是我们不能直接通过首地址访问这个对象，在对象创建时，栈里的首地址会指向数据段里生成的对象信息量表（hashmap形式），value指向堆里的对象

2. 对象
   
   创建的对象除了自己的内存之外，在低地址还存在object的内存，最后存放对象头，继承的原理是指是内存连续
3. 动态指派
   
   指子类有对应方法就不运行父类方法，在堆里的对象只有属性，没有方法，保留指针指向class
   
4. 直接内存
